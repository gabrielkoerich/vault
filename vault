#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.0"
CONFIG_DIR="${VAULT_CONFIG_DIR:-$HOME/.config/vault}"
PATHS_FILE="$CONFIG_DIR/paths"
SCAN_FILE="$CONFIG_DIR/scan.yml"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
SETTINGS_FILE="$CONFIG_DIR/settings"
VAULT_FILE="${VAULT_FILE:-$HOME/.vault.tar.age}"
MANIFEST_FILE="${VAULT_FILE%.tar.age}-manifest"

load_settings() {
  [ -f "$SETTINGS_FILE" ] && source "$SETTINGS_FILE"
  DELETE_METHOD="${DELETE_METHOD:-trash}"
  ENV_SCAN_DIRS="${ENV_SCAN_DIRS:-$HOME}"
  EXCLUDE_PATHS="${EXCLUDE_PATHS:-}"
}

is_excluded() {
  local p="$1"
  [ -z "$EXCLUDE_PATHS" ] && return 1
  local IFS=','
  for exc in $EXCLUDE_PATHS; do
    exc="$(eval echo "$exc")"
    [[ "$p" == "$exc" || "$p" == "$exc/"* ]] && return 0
  done
  return 1
}

usage() {
  cat <<EOF
vault $VERSION — lock down sensitive files with age encryption

usage:
  vault init        setup config and scan for sensitive files
  vault lockdown    encrypt and remove sensitive files from disk
  vault unlock      restore sensitive files from the encrypted vault
  vault scan        scan for exposed secrets and update paths config
  vault status      show whether vault is locked or unlocked
  vault paths       list configured sensitive paths
  vault version     show version

config:
  $PATHS_FILE           paths to lock (one per line)
  $SCAN_FILE            paths to scan for secrets (editable)

EOF
}

check_deps() {
  local missing=()
  for cmd in "$@"; do
    command -v "$cmd" &>/dev/null || missing+=("$cmd")
  done
  if [ ${#missing[@]} -gt 0 ]; then
    echo "error: missing dependencies: ${missing[*]}" >&2
    echo "install with: brew install ${missing[*]}" >&2
    exit 1
  fi
}

ensure_config() {
  if [ ! -f "$PATHS_FILE" ]; then
    echo "error: vault is not set up yet" >&2
    echo "run 'vault init' first" >&2
    exit 1
  fi
}

is_self() {
  local p="$1"
  # skip vault's own config, the vault file, and the vault script
  [[ "$p" == "$CONFIG_DIR" || "$p" == "$CONFIG_DIR/"* ]] && return 0
  [[ "$p" == "$VAULT_FILE" || "$p" == "$MANIFEST_FILE" ]] && return 0
  [[ "$p" == "$(command -v vault 2>/dev/null)" ]] && return 0
  return 1
}

read_paths() {
  load_settings
  local paths=()
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    local expanded
    expanded="$(eval echo "$line")"
    if [ -e "$expanded" ]; then
      if is_self "$expanded"; then
        echo "error: $line points to vault's own files — remove it from $PATHS_FILE" >&2
        exit 1
      fi
      paths+=("$expanded")
    fi
  done < "$PATHS_FILE"

  # optionally collect .env files
  local scan_dirs
  scan_dirs="$(eval echo "$ENV_SCAN_DIRS")"
  read -p "scan for .env files under $scan_dirs? (Y/n) " -n 1 -r
  echo ""
  if [[ ! $REPLY =~ ^[Nn]$ ]]; then
    while IFS= read -r envfile; do
      is_self "$envfile" && continue
      is_excluded "$envfile" && continue
      paths+=("$envfile")
    done < <(fd -t f -H -g '.env' $scan_dirs 2>/dev/null)
  fi

  printf '%s\n' "${paths[@]}"
}

cmd_init() {
  check_deps age fd rg

  if [ -f "$SETTINGS_FILE" ]; then
    echo "vault is already set up ($CONFIG_DIR)"
    echo "run 'vault scan' to update, or edit files in $CONFIG_DIR directly"
    return
  fi

  mkdir -p "$CONFIG_DIR"
  echo "setting up vault..."
  echo ""

  # delete method
  if command -v trash &>/dev/null; then
    read -p "use trash instead of rm for deletion? (Y/n) " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Nn]$ ]]; then
      echo "DELETE_METHOD=rm" >> "$SETTINGS_FILE"
    else
      echo "DELETE_METHOD=trash" >> "$SETTINGS_FILE"
    fi
  else
    echo "DELETE_METHOD=rm" >> "$SETTINGS_FILE"
    echo "tip: install 'trash' for recoverable deletion (brew install trash)"
  fi
  echo ""

  # .env scan directories
  read -p "directories to scan for .env files (default: \$HOME): " env_dirs
  if [ -z "$env_dirs" ]; then
    echo "ENV_SCAN_DIRS=\$HOME" >> "$SETTINGS_FILE"
  else
    echo "ENV_SCAN_DIRS=$env_dirs" >> "$SETTINGS_FILE"
  fi
  echo ""

  # excluded paths
  read -p "paths to exclude from scanning (comma-separated, or blank for none): " excludes
  if [ -n "$excludes" ]; then
    echo "EXCLUDE_PATHS=$excludes" >> "$SETTINGS_FILE"
  fi
  echo ""

  # run scan
  cmd_scan
  echo ""
  echo "done. review your paths with 'vault paths', then run 'vault lockdown'."
  echo "config: $CONFIG_DIR"
}

cmd_lockdown() {
  check_deps age fd
  ensure_config

  if [ -f "$VAULT_FILE" ]; then
    echo "error: $VAULT_FILE already exists — already locked? run 'vault unlock' first" >&2
    exit 1
  fi

  mapfile -t paths < <(read_paths)

  if [ ${#paths[@]} -eq 0 ]; then
    echo "nothing to lock — no sensitive files found"
    exit 0
  fi

  echo "locking ${#paths[@]} sensitive path(s):"
  printf '  %s\n' "${paths[@]}"

  # save manifest
  printf '%s\n' "${paths[@]}" > "$MANIFEST_FILE"

  # tar relative to $HOME and encrypt with passphrase
  echo ""
  echo "WARNING: if you lose your passphrase, you will lose access to all locked files."
  echo ""
  echo "enter a passphrase to encrypt the vault:"
  tar -cf - -C "$HOME" "${paths[@]/#$HOME\//}" | age -p -o "$VAULT_FILE"

  # verify before removing
  if [ ! -f "$VAULT_FILE" ]; then
    echo "error: vault not created, aborting — files are safe" >&2
    rm -f "$MANIFEST_FILE"
    exit 1
  fi

  # remove originals
  load_settings
  for p in "${paths[@]}"; do
    if [[ "$DELETE_METHOD" == "trash" ]] && command -v trash &>/dev/null; then
      trash "$p"
    else
      rm -rf "$p"
    fi
  done

  echo ""
  echo "locked. sensitive files encrypted to $VAULT_FILE"
  echo "run 'vault unlock' to restore"

  if [[ "$DELETE_METHOD" == "trash" ]]; then
    echo ""
    read -p "empty trash now? (y/n) " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      if [[ "$(uname)" == "Darwin" ]]; then
        osascript -e 'tell application "Finder" to empty the trash'
      fi
      echo "trash emptied"
    fi
  fi
}

cmd_unlock() {
  check_deps age
  if [ ! -f "$VAULT_FILE" ]; then
    echo "error: $VAULT_FILE not found — not locked?" >&2
    exit 1
  fi

  echo "enter your passphrase to decrypt the vault:"
  age --decrypt -o - "$VAULT_FILE" | tar -xf - -C "$HOME"

  rm -f "$VAULT_FILE" "$MANIFEST_FILE"
  echo "unlocked. all sensitive files restored"
}

cmd_scan() {
  check_deps fd rg
  load_settings
  mkdir -p "$CONFIG_DIR"
  touch "$PATHS_FILE"

  # copy default scan.yml if user doesn't have one
  if [ ! -f "$SCAN_FILE" ]; then
    local default_scan="$SCRIPT_DIR/scan.yml"
    # homebrew installs to share/vault/
    [ ! -f "$default_scan" ] && default_scan="$(brew --prefix 2>/dev/null)/share/vault/scan.yml"
    if [ -f "$default_scan" ]; then
      cp "$default_scan" "$SCAN_FILE"
      echo "created $SCAN_FILE from defaults"
      echo "edit it to customize what vault scans for"
      echo ""
    else
      echo "error: no scan.yml found" >&2
      exit 1
    fi
  fi

  local found=0
  add_path() {
    local p="$1"
    local label="$2"
    local entry="\$HOME/${p#$HOME/}"
    if ! rg -qF "$entry" "$PATHS_FILE"; then
      echo "$entry" >> "$PATHS_FILE"
      echo "  added: $entry ($label)"
      found=$((found + 1))
    fi
  }

  echo "scanning for exposed secrets..."

  # check paths from scan.yml
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    local raw="${line#- }"
    raw="${raw%%#*}"        # strip inline comments
    raw="${raw%"${raw##*[![:space:]]}"}"  # trim trailing whitespace
    local expanded
    expanded="$(eval echo "$raw")"
    if [ -e "$expanded" ] && ! is_excluded "$expanded"; then
      add_path "$expanded" "scan.yml"
    fi
  done < "$SCAN_FILE"

  # scan shell files for exported secrets
  for f in "$HOME/.zshrc" "$HOME/.zprofile" "$HOME/.bashrc" "$HOME/.bash_profile"; do
    if [ -f "$f" ] && rg -qi '(API_KEY|SECRET|TOKEN|PASSWORD|PRIVATE_KEY)=' "$f" 2>/dev/null; then
      add_path "$f" "secrets in shell config"
    fi
  done

  # scan for .env files
  local scan_dirs
  scan_dirs="$(eval echo "$ENV_SCAN_DIRS")"
  while IFS= read -r envfile; do
    is_excluded "$envfile" && continue
    add_path "$envfile" ".env file"
  done < <(fd -t f -H -g '.env' $scan_dirs 2>/dev/null || true)

  # scan for private key files
  while IFS= read -r keyfile; do
    local dir
    dir="$(dirname "$keyfile")"
    add_path "$dir" "private key found"
  done < <(rg -l --glob '*.pem' --glob '*.key' --glob '*.p12' 'PRIVATE KEY' "$HOME/.config" "$HOME/.local" 2>/dev/null || true)

  if [ "$found" -eq 0 ]; then
    echo "no new paths found — vault config is up to date"
  else
    echo ""
    echo "added $found new path(s) to $PATHS_FILE"
  fi
}

cmd_status() {
  if [ -f "$VAULT_FILE" ]; then
    echo "locked"
    if [ -f "$MANIFEST_FILE" ]; then
      echo ""
      echo "encrypted paths:"
      sed 's/^/  /' "$MANIFEST_FILE"
    fi
  else
    echo "unlocked"
  fi
}

cmd_paths() {
  ensure_config
  echo "configured paths ($PATHS_FILE):"
  echo ""
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    local expanded
    expanded="$(eval echo "$line")"
    if [ -e "$expanded" ]; then
      echo "  $line"
    else
      echo "  $line (missing)"
    fi
  done < "$PATHS_FILE"
}

case "${1:-}" in
  init|setup) cmd_init ;;
  lockdown|lock) cmd_lockdown ;;
  unlock) cmd_unlock ;;
  scan) cmd_scan ;;
  status) cmd_status ;;
  paths) cmd_paths ;;
  version|-v|--version) echo "vault $VERSION" ;;
  help|-h|--help|"") usage ;;
  *) echo "unknown command: $1" >&2; usage; exit 1 ;;
esac
