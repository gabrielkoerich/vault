#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.8"
CONFIG_DIR="${VAULT_CONFIG_DIR:-$HOME/.config/vault}"
PATHS_FILE="$CONFIG_DIR/paths"
SCAN_FILE="$CONFIG_DIR/scan.yml"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
SETTINGS_FILE="$CONFIG_DIR/settings"
VAULT_FILE="${VAULT_FILE:-$HOME/.vault.tar.age}"
MANIFEST_FILE="${VAULT_FILE%.tar.age}-manifest"
VAULTS_DIR="${VAULTS_DIR:-$HOME/.vaults}"
KEYCHAIN_PREFIX="${KEYCHAIN_PREFIX:-gabrielkoerich/vault}"
KEYCHAIN_DELETE_CONFIRM="${KEYCHAIN_DELETE_CONFIRM:-yes}"

load_settings() {
  # shellcheck source=/dev/null
  [ -f "$SETTINGS_FILE" ] && source "$SETTINGS_FILE"
  DELETE_METHOD="${DELETE_METHOD:-trash}"
  ENV_SCAN_DIRS="${ENV_SCAN_DIRS:-$HOME}"
  EXCLUDE_PATHS="${EXCLUDE_PATHS:-}"
}

is_excluded() {
  local p="$1"
  [ -z "$EXCLUDE_PATHS" ] && return 1
  local IFS=','
  for exc in $EXCLUDE_PATHS; do
    exc="$(eval echo "$exc")"
    [[ "$p" == "$exc" || "$p" == "$exc/"* ]] && return 0
  done
  return 1
}

usage() {
  cat <<EOF
vault $VERSION — lock down sensitive files with age encryption

usage:
  vault init        setup config and scan for sensitive files
  vault lockdown    encrypt and remove sensitive files from disk
  vault unlock      restore sensitive files from the encrypted vault
  vault create      create a named vault from explicit paths
  vault open        decrypt a named vault
  vault scan        scan for exposed secrets and update paths config
  vault status      show whether vault is locked or unlocked
  vault paths       list configured sensitive paths
  vault version     show version

config:
  $PATHS_FILE           paths to lock (one per line)
  $SCAN_FILE            paths to scan for secrets (editable)

EOF
}

check_deps() {
  local missing=()
  for cmd in "$@"; do
    command -v "$cmd" &>/dev/null || missing+=("$cmd")
  done
  if [ ${#missing[@]} -gt 0 ]; then
    echo "error: missing dependencies: ${missing[*]}" >&2
    echo "install with: brew install ${missing[*]}" >&2
    exit 1
  fi
}

ensure_config() {
  if [ ! -f "$PATHS_FILE" ]; then
    echo "error: vault is not set up yet" >&2
    echo "run 'vault init' first" >&2
    exit 1
  fi
}

keychain_service_for() {
  local name="${1:-default}"
  echo "${KEYCHAIN_PREFIX}:${name}"
}

is_darwin() {
  [[ "$(uname)" == "Darwin" ]]
}

keychain_get() {
  local name="${1:-default}"
  is_darwin || return 1
  local service
  service="$(keychain_service_for "$name")"
  security find-generic-password -a "$USER" -s "$service" -w 2>/dev/null
}

keychain_set() {
  local name="${1:-default}"
  local passphrase="$2"
  is_darwin || return 1
  local service
  service="$(keychain_service_for "$name")"
  security add-generic-password -a "$USER" -s "$service" -w "$passphrase" -U >/dev/null
}

keychain_delete() {
  local name="${1:-default}"
  is_darwin || return 1
  local service
  service="$(keychain_service_for "$name")"
  if security find-generic-password -a "$USER" -s "$service" >/dev/null 2>&1; then
    if [[ "$KEYCHAIN_DELETE_CONFIRM" == "yes" ]]; then
      read -p "delete keychain entry '$service'? (y/N) " -n 1 -r < /dev/tty
      echo "" > /dev/tty
      [[ ! $REPLY =~ ^[Yy]$ ]] && return 0
    fi
    security delete-generic-password -a "$USER" -s "$service" >/dev/null
  fi
}

read_passphrase() {
  local name="${1:-default}"
  local passphrase="$2"
  local passphrase_stdin="$3"

  if [ "$passphrase_stdin" -eq 1 ]; then
    passphrase="$(cat)"
  fi

  if [ -z "$passphrase" ]; then
    passphrase="$(keychain_get "$name" || true)"
  fi

  printf '%s' "$passphrase"
}

prompt_passphrase_create() {
  local name="${1:-default}"
  local passphrase=""
  local confirm=""

  echo ""
  echo "no passphrase found in keychain for '$(keychain_service_for "$name")'"
  echo "enter a new passphrase (will be saved to keychain)"
  echo ""
  read -r -s -p "passphrase: " passphrase < /dev/tty
  echo "" > /dev/tty
  read -r -s -p "confirm passphrase: " confirm < /dev/tty
  echo "" > /dev/tty

  if [ -z "$passphrase" ] || [ "$passphrase" != "$confirm" ]; then
    echo "error: passphrases do not match" >&2
    exit 1
  fi

  printf '%s' "$passphrase"
}

prompt_passphrase_open() {
  local name="${1:-default}"
  local passphrase=""
  echo ""
  echo "no passphrase found in keychain for '$(keychain_service_for "$name")'"
  echo "enter the passphrase to decrypt"
  echo ""
  read -r -s -p "passphrase: " passphrase < /dev/tty
  echo "" > /dev/tty
  printf '%s' "$passphrase"
}

ensure_passphrase_create() {
  local name="${1:-default}"
  local passphrase="$2"
  local passphrase_stdin="$3"

  passphrase="$(read_passphrase "$name" "$passphrase" "$passphrase_stdin")"
  if [ -z "$passphrase" ]; then
    passphrase="$(prompt_passphrase_create "$name")"
  fi
  printf '%s' "$passphrase"
}

ensure_passphrase_open() {
  local name="${1:-default}"
  local passphrase="$2"
  local passphrase_stdin="$3"

  passphrase="$(read_passphrase "$name" "$passphrase" "$passphrase_stdin")"
  if [ -z "$passphrase" ]; then
    passphrase="$(prompt_passphrase_open "$name")"
  fi
  printf '%s' "$passphrase"
}

is_self() {
  local p="$1"
  # skip vault's own config, the vault file, and the vault script
  [[ "$p" == "$CONFIG_DIR" || "$p" == "$CONFIG_DIR/"* ]] && return 0
  [[ "$p" == "$VAULTS_DIR" || "$p" == "$VAULTS_DIR/"* ]] && return 0
  [[ "$p" == "$VAULT_FILE" || "$p" == "$MANIFEST_FILE" ]] && return 0
  [[ "$p" == "$(command -v vault 2>/dev/null)" ]] && return 0
  return 1
}

read_paths() {
  load_settings
  local paths=()
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    local expanded
    expanded="$(eval echo "$line")"
    if [ -e "$expanded" ]; then
      if is_self "$expanded"; then
        echo "error: $line points to vault's own files — remove it from $PATHS_FILE" >&2
        exit 1
      fi
      paths+=("$expanded")
    fi
  done < "$PATHS_FILE"

  # optionally collect .env files
  local scan_dirs
  scan_dirs="$(eval echo "$ENV_SCAN_DIRS")"
  read -p "scan for .env files under $scan_dirs? (Y/n) " -n 1 -r < /dev/tty
  echo "" > /dev/tty
  if [[ ! $REPLY =~ ^[Nn]$ ]]; then
    while IFS= read -r envfile; do
      is_self "$envfile" && continue
      is_excluded "$envfile" && continue
      paths+=("$envfile")
    done < <(fd -t f -H --no-ignore -g '.env*' "$scan_dirs" 2>/dev/null)
  fi

  printf '%s\n' "${paths[@]}"
}

cmd_init() {
  check_deps age fd rg

  if [ -f "$SETTINGS_FILE" ]; then
    echo "vault is already set up ($CONFIG_DIR)"
    echo "run 'vault scan' to update, or edit files in $CONFIG_DIR directly"
    return
  fi

  mkdir -p "$CONFIG_DIR"
  echo "setting up vault..."
  echo ""

  # delete method
  if command -v trash &>/dev/null; then
    read -p "use trash instead of rm for deletion? (Y/n) " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Nn]$ ]]; then
      echo "DELETE_METHOD=rm" >> "$SETTINGS_FILE"
    else
      echo "DELETE_METHOD=trash" >> "$SETTINGS_FILE"
    fi
  else
    echo "DELETE_METHOD=rm" >> "$SETTINGS_FILE"
    echo "tip: install 'trash' for recoverable deletion (brew install trash)"
  fi
  echo ""

  # .env scan directories
  read -rp "directories to scan for .env files (default: \$HOME): " env_dirs
  if [ -z "$env_dirs" ]; then
    echo "ENV_SCAN_DIRS=\$HOME" >> "$SETTINGS_FILE"
  else
    echo "ENV_SCAN_DIRS=$env_dirs" >> "$SETTINGS_FILE"
  fi
  echo ""

  # excluded paths
  read -rp "paths to exclude from scanning (comma-separated, or blank for none): " excludes
  if [ -n "$excludes" ]; then
    echo "EXCLUDE_PATHS=$excludes" >> "$SETTINGS_FILE"
  fi
  echo ""

  # run scan
  cmd_scan
  echo ""
  echo "done. review your paths with 'vault paths', then run 'vault lockdown'."
  echo "config: $CONFIG_DIR"
}

cmd_lockdown() {
  check_deps age fd
  ensure_config

  if [ -f "$VAULT_FILE" ]; then
    echo "error: $VAULT_FILE already exists — already locked? run 'vault unlock' first" >&2
    exit 1
  fi

  paths=()
  while IFS= read -r line; do
    paths+=("$line")
  done < <(read_paths)

  if [ ${#paths[@]} -eq 0 ]; then
    echo "nothing to lock — no sensitive files found"
    exit 0
  fi

  echo "locking ${#paths[@]} sensitive path(s):"
  printf '  %s\n' "${paths[@]}"

  # save manifest
  printf '%s\n' "${paths[@]}" > "$MANIFEST_FILE"

  # tar and encrypt with passphrase
  local tmp_tar
  tmp_tar="$(mktemp)"
  trap 'rm -f "$tmp_tar"' EXIT
  tar -cf "$tmp_tar" -C "$HOME" "${paths[@]/#$HOME\//}" 2> >(grep -v 'socket ignored' >&2)

  echo ""
  echo "WARNING: if you lose your passphrase, you will lose access to all locked files."
  echo ""
  local passphrase=""
  passphrase="$(ensure_passphrase_create "default" "" 0)"
  AGE_PASSPHRASE="$passphrase" age -p -o "$VAULT_FILE" "$tmp_tar"
  keychain_set "default" "$passphrase" || true
  rm -f "$tmp_tar"

  # verify before removing
  if [ ! -f "$VAULT_FILE" ]; then
    echo "error: vault not created, aborting — files are safe" >&2
    rm -f "$MANIFEST_FILE"
    exit 1
  fi

  # remove originals
  load_settings
  for p in "${paths[@]}"; do
    [ -e "$p" ] || [ -L "$p" ] || continue
    if [[ "$DELETE_METHOD" == "trash" ]] && command -v trash &>/dev/null; then
      trash "$p"
    else
      rm -rf "$p"
    fi
  done

  echo ""
  echo "locked. sensitive files encrypted to $VAULT_FILE"
  echo "run 'vault unlock' to restore"

  if [[ "$DELETE_METHOD" == "trash" ]]; then
    echo ""
    read -p "empty trash now? (y/n) " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      if [[ "$(uname)" == "Darwin" ]]; then
        osascript -e 'tell application "Finder" to empty the trash'
      fi
      echo "trash emptied"
    fi
  fi
}

cmd_unlock() {
  check_deps age
  local keep_keychain=0
  while [[ "${1:-}" == --* ]]; do
    case "$1" in
      --keep-keychain)
        keep_keychain=1
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        echo "unknown option: $1" >&2
        exit 1
        ;;
    esac
  done
  if [ ! -f "$VAULT_FILE" ]; then
    echo "error: $VAULT_FILE not found — not locked?" >&2
    exit 1
  fi

  local tmp_tar
  tmp_tar="$(mktemp)"
  trap 'rm -f "$tmp_tar"' EXIT
  local passphrase=""
  passphrase="$(ensure_passphrase_open "default" "" 0)"
  AGE_PASSPHRASE="$passphrase" age --decrypt -o "$tmp_tar" "$VAULT_FILE"
  tar -xf "$tmp_tar" -C "$HOME"
  rm -f "$tmp_tar"

  rm -f "$VAULT_FILE" "$MANIFEST_FILE"
  if [ "$keep_keychain" -eq 0 ]; then
    keychain_delete "default" || true
  fi
  echo "unlocked. all sensitive files restored"
}

cmd_create() {
  check_deps age

  local passphrase=""
  local passphrase_stdin=0
  while [[ "${1:-}" == --* ]]; do
    case "$1" in
      --passphrase)
        passphrase="${2:-}"
        shift 2
        ;;
      --passphrase-stdin)
        passphrase_stdin=1
        shift
        ;;
      --)
        shift
        break
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        echo "unknown option: $1" >&2
        exit 1
        ;;
    esac
  done

  local name="${1:-}"
  shift || true

  if [ -z "$name" ]; then
    echo "error: vault name is required" >&2
    exit 1
  fi

  if [ $# -eq 0 ]; then
    echo "error: provide at least one path to lock" >&2
    exit 1
  fi

  mkdir -p "$VAULTS_DIR"
  local vault_file="$VAULTS_DIR/$name.tar.age"
  local manifest_file="$VAULTS_DIR/$name-manifest"

  if [ -f "$vault_file" ]; then
    echo "error: $vault_file already exists — already locked? run 'vault open $name' first" >&2
    exit 1
  fi

  local paths=()
  for raw in "$@"; do
    local expanded
    expanded="$(eval echo "$raw")"
    if [ ! -e "$expanded" ]; then
      echo "error: path not found: $raw" >&2
      exit 1
    fi
    if is_self "$expanded"; then
      echo "error: $raw points to vault's own files — choose another path" >&2
      exit 1
    fi
    # absolutize
    if [[ "$expanded" != /* ]]; then
      expanded="$(cd "$(dirname "$expanded")" && pwd)/$(basename "$expanded")"
    fi
    paths+=("$expanded")
  done

  echo "locking ${#paths[@]} path(s) to named vault '$name':"
  printf '  %s\n' "${paths[@]}"

  printf '%s\n' "${paths[@]}" > "$manifest_file"

  local tmp_tar
  tmp_tar="$(mktemp)"
  trap 'rm -f "$tmp_tar"' EXIT
  tar -cf "$tmp_tar" -P "${paths[@]}" 2> >(grep -v 'socket ignored' >&2)

  echo ""
  echo "WARNING: if you lose your passphrase, you will lose access to this vault."
  echo ""

  passphrase="$(ensure_passphrase_create "$name" "$passphrase" "$passphrase_stdin")"
  AGE_PASSPHRASE="$passphrase" age -p -o "$vault_file" "$tmp_tar"
  keychain_set "$name" "$passphrase" || true
  rm -f "$tmp_tar"

  if [ ! -f "$vault_file" ]; then
    echo "error: vault not created, aborting — files are safe" >&2
    rm -f "$manifest_file"
    exit 1
  fi

  load_settings
  for p in "${paths[@]}"; do
    [ -e "$p" ] || [ -L "$p" ] || continue
    if [[ "$DELETE_METHOD" == "trash" ]] && command -v trash &>/dev/null; then
      trash "$p"
    else
      rm -rf "$p"
    fi
  done

  echo ""
  echo "locked. named vault saved to $vault_file"
  echo "run 'vault open $name' to restore"
}

cmd_open() {
  check_deps age

  local passphrase=""
  local passphrase_stdin=0
  local keep_keychain=0
  while [[ "${1:-}" == --* ]]; do
    case "$1" in
      --keep-keychain)
        keep_keychain=1
        shift
        ;;
      --passphrase)
        passphrase="${2:-}"
        shift 2
        ;;
      --passphrase-stdin)
        passphrase_stdin=1
        shift
        ;;
      --)
        shift
        break
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        echo "unknown option: $1" >&2
        exit 1
        ;;
    esac
  done

  local name="${1:-}"
  if [ -z "$name" ]; then
    echo "error: vault name is required" >&2
    exit 1
  fi

  local vault_file="$VAULTS_DIR/$name.tar.age"
  local manifest_file="$VAULTS_DIR/$name-manifest"
  if [ ! -f "$vault_file" ]; then
    echo "error: $vault_file not found — not locked?" >&2
    exit 1
  fi

  local tmp_tar
  tmp_tar="$(mktemp)"
  trap 'rm -f "$tmp_tar"' EXIT

  passphrase="$(ensure_passphrase_open "$name" "$passphrase" "$passphrase_stdin")"
  AGE_PASSPHRASE="$passphrase" age --decrypt -o "$tmp_tar" "$vault_file"
  tar -xf "$tmp_tar" -P
  rm -f "$tmp_tar"

  rm -f "$vault_file" "$manifest_file"
  if [ "$keep_keychain" -eq 0 ]; then
    keychain_delete "$name" || true
  fi
  echo "unlocked. named vault '$name' restored"
}

cmd_scan() {
  check_deps fd rg
  load_settings
  mkdir -p "$CONFIG_DIR"
  touch "$PATHS_FILE"

  # copy default scan.yml if user doesn't have one
  if [ ! -f "$SCAN_FILE" ]; then
    local default_scan="$SCRIPT_DIR/scan.yml"
    # homebrew installs to share/vault/
    [ ! -f "$default_scan" ] && default_scan="$(brew --prefix 2>/dev/null)/share/vault/scan.yml"
    if [ -f "$default_scan" ]; then
      cp "$default_scan" "$SCAN_FILE"
      echo "created $SCAN_FILE from defaults"
      echo "edit it to customize what vault scans for"
      echo ""
    else
      echo "error: no scan.yml found" >&2
      exit 1
    fi
  fi

  local found=0
  add_path() {
    local p="$1"
    local label="$2"
    local entry="\$HOME/${p#"$HOME"/}"
    if ! rg -qF "$entry" "$PATHS_FILE"; then
      echo "$entry" >> "$PATHS_FILE"
      echo "  added: $entry ($label)"
      found=$((found + 1))
    fi
  }

  echo "scanning for exposed secrets..."

  # check paths from scan.yml
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    local raw="${line#- }"
    raw="${raw%%#*}"        # strip inline comments
    raw="${raw%"${raw##*[![:space:]]}"}"  # trim trailing whitespace
    local expanded
    expanded="$(eval echo "$raw")"
    if [ -e "$expanded" ] && ! is_excluded "$expanded"; then
      add_path "$expanded" "scan.yml"
    fi
  done < "$SCAN_FILE"

  # scan shell files for exported secrets
  for f in "$HOME/.zshrc" "$HOME/.zprofile" "$HOME/.bashrc" "$HOME/.bash_profile"; do
    if [ -f "$f" ] && rg -qi '(API_KEY|SECRET|TOKEN|PASSWORD|PRIVATE_KEY)=' "$f" 2>/dev/null; then
      add_path "$f" "secrets in shell config"
    fi
  done

  # scan for .env files
  local scan_dirs
  scan_dirs="$(eval echo "$ENV_SCAN_DIRS")"
  while IFS= read -r envfile; do
    is_excluded "$envfile" && continue
    add_path "$envfile" ".env file"
  done < <(fd -t f -H --no-ignore -g '.env*' "$scan_dirs" 2>/dev/null || true)

  # scan for private key files
  while IFS= read -r keyfile; do
    local dir
    dir="$(dirname "$keyfile")"
    add_path "$dir" "private key found"
  done < <(rg -l --glob '*.pem' --glob '*.key' --glob '*.p12' 'PRIVATE KEY' "$HOME/.config" "$HOME/.local" 2>/dev/null || true)

  if [ "$found" -eq 0 ]; then
    echo "no new paths found — vault config is up to date"
  else
    echo ""
    echo "added $found new path(s) to $PATHS_FILE"
  fi
}

cmd_status() {
  if [ -f "$VAULT_FILE" ]; then
    echo "locked"
    if [ -f "$MANIFEST_FILE" ]; then
      echo ""
      echo "encrypted paths:"
      sed 's/^/  /' "$MANIFEST_FILE"
    fi
  else
    echo "unlocked"
  fi
}

cmd_paths() {
  ensure_config
  echo "configured paths ($PATHS_FILE):"
  echo ""
  while IFS= read -r line; do
    [[ -z "$line" || "$line" =~ ^# ]] && continue
    local expanded
    expanded="$(eval echo "$line")"
    if [ -e "$expanded" ]; then
      echo "  $line"
    else
      echo "  $line (missing)"
    fi
  done < "$PATHS_FILE"
}

case "${1:-}" in
  init|setup) cmd_init ;;
  lockdown|lock) cmd_lockdown ;;
  unlock) cmd_unlock ;;
  create) shift; cmd_create "$@" ;;
  open) shift; cmd_open "$@" ;;
  scan) cmd_scan ;;
  status) cmd_status ;;
  paths) cmd_paths ;;
  version|-v|--version) echo "vault $VERSION" ;;
  help|-h|--help|"") usage ;;
  *) echo "unknown command: $1" >&2; usage; exit 1 ;;
esac
